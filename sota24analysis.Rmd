---
title: "State of the AnVIL 2024"
author: "Kate Isaac, Elizabeth Humphries, & Ava Hoffman"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
library(googlesheets4)
library(tidyverse)
library(magrittr) #for %<>%
library(here)
library(grid) #for Grobs and unit()
library(ggrepel) #for geom_text_repel()
library(patchwork)
```

# Read in data

The google sheet we are reading in is stored in an AnVIL Google drive folder `State of the AnVIL 2024`. Its permissions are restricted such that only people with access can open with the link. Using `gs4_auth()` to authorize my google account before running this code, I needed to change the `scopes` argument, specifically `scopes=spreadsheets.readonly` was necessary. 

In this google sheet, each question is a column, and each response to the survey is a row. If the respondent wasn't asked or didn't answer a specific question, there is an NA in the corresponding row/column. 

```{r}
gs4_auth(email = "kathryn.j.isaac@gmail.com", scopes="spreadsheets.readonly")
resultsRaw <-
  googlesheets4::read_sheet(
    "https://docs.google.com/spreadsheets/d/1wDMNC6BD2AaIwh_GOkPTpl1tvAyLwVBQgAvOD2rYrX0/edit?usp=sharing",
  na = c("NA", "na", ""))
```

# Clean data

## Set Column Names

<details><summary>Description of variable definitions and steps</summary>

We have a codebook that is a tab delimited file and has 4 columns, and each row represents a question in the survey. The first column lists a/the question from the survey (`SurveyColNames`); the second column lists a corresponding simplified column name for that survey question (`SimplifedColNames`); the third column describes the variable format (`VariableFormat`), e.g, is it a double, or a character;  the fourth column gives a lengthier description of the question (`Description`), e.g., who was asked it, what possible answers are, etc.

This code block reads in that codebook and specifically selects the `SimplifiedColNames` column. It then renames the column names of the raw results from the google sheet (where each question is a column) with these simplified column names. 

</details>

```{r}
simplifiedColNames <-
  read_delim(here("data/codebook.txt"),
             delim = "\t",
             col_select = SimplifiedColNames)
resultsTidy <-
  resultsRaw %>% `colnames<-`(unlist(simplifiedColNames))
```

## Keep last response if duplicated according to email (if email provided)

Choosing to select the last response because the respondent may have spent more time thinking about how they wanted to respond after their initial response. 

<details><summary>Description of variable definitions and steps</summary>

* The `table` function tabulates the number of occurrences, and we tell it to ignore literal NAs. Because providing an email was optional, we expect many NA responses. The `table` function, by ignoring NAs, will return the unique emails and the number of times each email was used. We store the tabulated results in the variable `tabulatedEmails`
* Using the `sum` function, we look to see how many emails/responses are provided more than once. `tabulatedEmails > 1` is returning a vector of TRUEs and FALSEs where TRUE means that there was more than one instance/count of a given email and FALSE means there wasn't. The `sum` function in essence counts the number of TRUEs and if the `sum` is greater than 0, that means there is at least one duplicated email whose count is greater than 1.
* `duplicatedEmails` reports which emails are duplicated by using the tabulated/table of emails. First it identifies which emails were observed more than once, using the `which` function, and uses the indices returned from that to index the `names` of the tabulated emails, grabbing the specific emails.
* We want to know which entries from the overall survey responses to remove for each duplicated email. Ideally, we want to remove the responses all at the same time or go backwards removing one at a time, because we don't want to affect downstream indices. The approach here, keeps track of all the indices of interest and removed them at the same time. 
  * Therefore, we'll use `lapply` to loop through the duplicated emails (`duplicatedEmails`) and grab the index for survey responses associated with that email address (`which(resultsTidy$Email == duplicatedEmails[x])`).
  * However, we want to keep the last survey response for each duplicated email. Therefore, we wrap that `which` function in `head(_,-1 )` function so that it grabs all indices except the last one. 
  * Finally, we `unlist` the indices so that there's a single vector associated with indices for any duplicated email responses to be removed `IDXs_to_remove`. And since we want to remove them all at the same time, we subset  `resultsTidy`, grabbing every row except those in `IDXs_to_remove`, as denoted by the `-`.

</details>

```{r}

tabulatedEmails <- table(resultsTidy$Email, useNA = "no")

if (sum(tabulatedEmails > 1) > 0) {
  duplicatedEmails <-
    names(tabulatedEmails)[which(tabulatedEmails > 1)]
  IDXs_to_remove <-
    unlist(lapply(1:length(duplicatedEmails), function(x)
      head(
        which(resultsTidy$Email == duplicatedEmails[x]),-1
      )))
  resultsTidy <- resultsTidy[-IDXs_to_remove, ]
}

nrow(resultsTidy)
```

## Identify type of user

<details><summary>Question and possible answers</summary>

> How would you describe your current usage the AnVIL platform?

Possible answers include:

* For completed/long-term projects (e.g., occasional updates/maintenance as needed) 
* For ongoing projects (e.g., consistent project development and/or work) 
* For short-term projects (e.g., short, intense bursts separated by a few months) 
* I do no currently use the AnVIL, but have in the past
* I have never heard of the AnVIL
* I have never used the AnVIL, but have heard of it.

The first three possible answers represent current or returning AnVIL users. The last three possible answers represent potential AnVIL users.

</details>

<details><summary>Description of variable definitions and steps</summary>

We use `case_when` to evaluate the response in the `CurrentUsageDescription` column and assign a corresponding, simplified label of "CurrentUser" or "PotentialUser'. In other words we translate the given response to a user label. Using the `case_when` as the internal nested function of the `mutate` function, means that the translation is then saved in a new column, `UserType`.

</details>

```{r}
resultsTidy %<>%
  mutate(
    UserType = case_when(
      CurrentUsageDescription == "For ongoing projects (e.g., consistent project development and/or work)" ~ "CurrentUser",
      CurrentUsageDescription == "For completed/long-term projects (e.g., occasional updates/maintenance as needed)" ~ "CurrentUser",
      CurrentUsageDescription == "For short-term projects (e.g., short, intense bursts separated by a few months)" ~ "CurrentUser",
      CurrentUsageDescription == "I do not currently use the AnVIL, but have in the past" ~ "PotentialUser",
      CurrentUsageDescription == "I have never used the AnVIL, but have heard of it" ~ "PotentialUser",
      CurrentUsageDescription == "I have never heard of the AnVIL" ~ "PotentialUser"
    )
  ) %>% 
  mutate(UserType = factor(UserType, levels = c("PotentialUser", "CurrentUser")))
```

## Synchronize Institution Names

<details><summary>Question and possible answers</summary>

> What institution are you affiliated with?

Free response for answers

</details>

This synchronization corrects for the various spellings and capitalizations used for the same institution (ex, Johns Hopkins and Johns Hopkins University refer to the same institution, despite the difference in the free responses).

<details><summary>Description of variable definitions and steps</summary>

We use a `recode()` within a `mutate()` to synchronize the institutional affiliations as necessary

</details>


```{r}
resultsTidy %<>%
  mutate(
    InstitutionalAffiliation =
      recode(
        InstitutionalAffiliation,
        "Broad" = "Broad Institute",
        "broad institute" = "Broad Institute",
        "CUNY School of Public Health; Roswell Park Comprehensive Cancer Center" = "City University of New York",
        "harvard" = "Harvard University",
        "Harvard Public Health" = "Harvard University",
        "Johns hopkins" = "Johns Hopkins",
        "Johns Hopkins University" = "Johns Hopkins",
        "OHSU" = "Oregon Health & Science University",
        "OHSU (Knight Center)" = "Oregon Health & Science University",
        "The Ohio State University" = "Ohio State University",
        "UCSC" = "University of California Santa Cruz",
        "univ. ca. santa cruz" = "University of California Santa Cruz",
        "university of California santa cruz" = "University of California Santa Cruz",
        "UMASS Chan Medical School" = "UMass Chan Medical School",
        "Umass Chan Medical School" = "UMass Chan Medical School",
        "Washington University in St Louis" = "Washington University in St. Louis",
        "yikongene" = "Yikon Genomics",
        "v" = "Unknown"
      )
  )
```

## Highest degree attained

<details><summary>Question and possible answers</summary

> What is the highest degree you have attained?

Possible answers include (and multiple choices could be selected and would be comma separated if so)

* High school or equivalent
* Bachelor's degree
* Master's degree in progress
* Master's degree
* PhD in progress
* PhD
* MD in progress
* MD
* Other (with free text entry)

</details>

<details><summary>Description of variable definitions and steps</summary>

Because multiple responses could be selected and those would be comma separated and because free text response was possible if other was selected, we need to tidy the data from this question. From visual inspection of the data, I see that the only time multiple responses were selected were for MD/PhD. No other's were selected. So we'll just recode "PhD, MD" to be "MD/PhD" 

Let's also set the factor levels to follow the general progress of degrees

</details>


```{r}
resultsTidy %<>%
  mutate(
    Degrees =
      factor(recode(Degrees, "PhD, MD" = "MD/PhD"), levels = c("High School or equivalent", "Bachelor's degree", "Master's degree in progress", "Master's degree", "PhD in progress", "PhD", "MD in progress", "MD", "MD/PhD"))
  )
```

## Simplified experience status for various research categories (clinical, human genomics, non-human genomics)

Want to add three columns that act as flags reporting if the respondent is 

* experienced with clinical research, specifically either moderately or extremely experienced in working with human clinical data
* experienced with human genomics research, specifically is moderately or extremely experienced in working with human genomics data
* experienced with non-human genomics research expert, specifically is moderately or extremely experienced in working with non-human genomics data

We will use this information later to subset responses when considering popular tools or datasets.

<details><summary>Description of variable definitions and steps</summary>

We use a `mutate` together with 3 `case_when`'s. 

* If the `HumanClinicalExperience` column response is "Moderately experienced" or "Extremely experienced", we mark that respondent as a human clinical research expert in the `clinicalFlag` column (`TRUE`). Otherwise, we mark a `FALSE` to signify they are not a clinical research expert.
* If the `HumanGenomicExperience` column response is "Moderately experienced" or "Extremely experienced", we mark that respondent as a human genomic research expert in the `humanGenomicFlag` column (`TRUE`). Otherwise, we again mark a `FALSE` to signify not an expert.
* If the `NonHumanGenomicExperience` column response is "Moderately experienced" or "Extremely experienced", we mark that respondent as a non-human genomic research expert in the `nonHumanGenomicFlag` column (`TRUE`). Otherwise, we again mark a `FALSE` to signify not an expert.

</details>

```{r}
resultsTidy %<>%
  mutate(
  clinicalFlag = case_when(
           HumanClinicalExperience == "Moderately experienced" | HumanClinicalExperience == "Extremely experienced" ~ TRUE,
           .default = FALSE
         ),
  humanGenomicFlag = case_when(
           HumanGenomicExperience == "Moderately experienced" | HumanGenomicExperience == "Extremely experienced" ~ TRUE,
           .default = FALSE
         ),
  nonHumanGenomicFlag = case_when(NonHumanGenomicExperience == "Moderately experienced" | NonHumanGenomicExperience == "Extremely experienced" ~ TRUE,
          .default = FALSE)
  )
```

# Demographics

## Institutional Affiliations

Elizabeth Humphries grouped institutional affiliations into a limited set of categories: R1 University, R2 University, Community College, Medical Center or School, International Location, Research Center, NIH, Industry, Unknown and we notated those groupings/labels within the `institution_codebook.txt` data file, . Grouping into limited institutional affiliation categories allows us to consolidate free answers for easier data visualization and identification of trends. 

<details><summary>Description of variable definitions and steps</summary>

We use a `read_delim()` to read in the institution_codebook file, and select just the `InstitutionalAffiliation` and `InstitutionalType` columns (ignoring the column that specifies how institutions were entered by survey respondents). We then use a full_join by the `InstitutionalAffiliation` column to add an `InstitutionalType` column such that the category labels are now included as a new column, joining the appropriate values dependent upon the `InstitutionalAffiliation` column.

</details>

```{r}
institutionCodeBook <- read_delim(here("data/institution_codebook.txt"), delim="\t", col_select = c(InstitutionalAffiliation, InstitutionalType))

resultsTidy <- full_join(resultsTidy, institutionCodeBook, by = "InstitutionalAffiliation")
```
### Further simplify Institutional Affiliations to focus on Research Intensive, Education Focused, and Industry & Other

```{r}
resultsTidy %<>% 
  mutate(FurtherSimplifiedInstitutionalType = 
           case_when(
             InstitutionalType == "R1 University" ~ "Research Intensive",
             InstitutionalType == "Research Center" ~ "Research Intensive",
             InstitutionalType == "Medical Center or School" ~ "Research Intensive",
             InstitutionalType == "NIH" ~ "Research Intensive",
             InstitutionalType == "R2 University" ~ "Education Focused",
             InstitutionalType == "Community College" ~ "Education Focused",
             InstitutionalType == "Industry" ~ "Industry & Other",
             InstitutionalType == "International Location" ~ "Industry & Other",
             InstitutionalType == "Unknown" ~ "Industry & Other"
           )
         )
```


### Number of institutions represented in responses

```{r}
length(unique(resultsTidy$InstitutionalAffiliation))
```

### Institution type

Let's make a bar chart that shows how many of each institution, colored by institution type

<details><summary>Description of variable definitions and steps</summary>

We first prepare the data by selecting the columns of interest from `resultsTidy`: `InstitutionalAffiliation` and `InstitutionalType`. And we use the `group_by` and `summarize( = n())` functions to add a count (`InstitutionalCount`) for every InstitutionalAffiliation. We want to include the InstitutionalType in the group_by even though it's redundant for what we're displaying since we'll want to color by institution type. 

We then plot the data with the Affiliation on the y-axis (reordered by the count so largest count is on top),
the count on the x-axis, and the fill color being the institutional type. 

We change some theme and label elements and add a grob annotation to specify how many unique institutions are represented in this graph. 

</details>

```{r}
resultsTidy %>%
  group_by(InstitutionalAffiliation, InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalAffiliation, InstitutionalCount),
    x = InstitutionalCount,
    fill = InstitutionalType
  )) + geom_bar(stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("Institutional Affiliation") + xlab("Count") +
  ggtitle("What institution are you affiliated with?")+
  annotation_custom(textGrob(paste("There are\n", length(unique(resultsTidy$InstitutionalAffiliation))  ,"\nunique institutions"), gp=gpar(fontsize=8, fontface = "bold")),xmin=7,xmax=7,ymin=3,ymax=3) +
  coord_cartesian(clip = "off")

ggsave(here("plots/institutionalAffilition_allResponses.png"))
```

Taking a less granular approach, and aggregating by institution type rather than looking at names of institutions

```{r}
resultsTidy %>%
  mutate(UserType = factor(UserType, levels = c("PotentialUser", "CurrentUser"))) %>%
  group_by(UserType, InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalType, InstitutionalCount, sum),
    x = InstitutionalCount,
    fill = UserType
  )) + geom_bar(position = "stack", stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("Institutional Affiliation") + xlab("Count") +
  ggtitle("Institutional Affiliation for All Survey Respondents")+
  annotation_custom(textGrob(paste("There are\n", length(unique(resultsTidy$InstitutionalAffiliation))  ,"\nunique institutions"), gp=gpar(fontsize=8, fontface = "bold")),xmin=34,xmax=34,ymin=2.5,ymax=2.5) +
  coord_cartesian(clip = "off") +
  #scale_fill_manual(values = c("#035C94", "#E0DD10")) +
  scale_fill_manual(values = c("#E0DD10", "#035C94")) +
  ggtitle("What institution are you affiliated with?")

ggsave(here("plots/institutionalType_allResponses_colorUserType.png"))

```

Further simplify it even more

```{r}
resultsTidy %>%
  mutate(UserType = factor(UserType, levels = c("PotentialUser", "CurrentUser"))) %>%
  mutate(FurtherSimplifiedInstitutionalType = factor(FurtherSimplifiedInstitutionalType, levels = c("Industry & Other", "Education Focused", "Research Intensive"))) %>%
  group_by(UserType, FurtherSimplifiedInstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = FurtherSimplifiedInstitutionalType,
    x = InstitutionalCount,
    fill = UserType
  )) + geom_bar(position = "stack", stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("") + 
  xlab("Count") +
  ggtitle("Institutional Affiliation for All Survey Respondents") +
  annotation_custom(textGrob("- R1 University     \n- Med Campus      \n- Research Center\n- NIH                     ", gp = gpar(fontsize = 8)), xmin = -8.5, xmax = -8.5, ymin = 2.65, ymax = 2.65) +
  annotation_custom(textGrob("- Industry             \n- International Loc\n- Unknown           ", gp = gpar(fontsize = 8)), xmin = -8.5, xmax = -8.5, ymin = .7, ymax = .7) +
  annotation_custom(textGrob("- R2 University         \n- Community College", gp=gpar(fontsize=8)),xmin=-8.5,xmax=-8.5,ymin=1.75,ymax=1.75) +
  coord_cartesian(clip = "off") +
  scale_fill_manual(values = c("#E0DD10", "#035C94")) +
  ggtitle("What institution are you affiliated with?")

ggsave(here("plots/institutionalType_simplified_allResponses_colorUserType.png"))

```


#### Just for Current/Returning Users

The above plot was for all survey responses. Here we want to focus on institutions represented by just current users of AnVIL. 

<details><summary>Description of variable definitions and steps</summary>

We first select rows/responses that are just from Current users. Then we prepare the data and plot following the same scheme as above.

</details>


```{r}
resultsTidy %>%
  filter(UserType == "CurrentUser") %>%
  group_by(InstitutionalAffiliation, InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalAffiliation, InstitutionalCount),
    x = InstitutionalCount,
    fill = InstitutionalType
  )) + geom_bar(stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("Institutional Affiliation") + xlab("Count") +
  ggtitle(bquote('Institutional Affilition for' ~ bold('Current User') ~ 'Respondents')) +
  annotation_custom(textGrob(paste("There are\n", nrow(unique(resultsTidy[which(resultsTidy$UserType == "CurrentUser"), "InstitutionalAffiliation"]))  ,"\nunique institutions"), gp=gpar(fontsize=8, fontface = "bold")),xmin=5.5,xmax=5.5,ymin=3,ymax=3) +
  coord_cartesian(clip = "off")

ggsave(here("plots/institutionalAffilition_currentUserResponses.png"))
```

Taking a less granular approach, and just looking at institution type rather than names of institutions. Saving the plot into a variable so that we can combine it with the one for potential users later. 

Note that the x- and y-axis labels are turned off since this will be the top plot when combined, also simplified the title to just say Current Users. Turned off the legend.

Also used `scale_fill_manual` to set specific colors for the institution types in order to sync colors for institution types in this and the potential users version (`institutionTypePotential`) (more info on this with that plot below).

```{r}
institutionTypeCurrent <- resultsTidy %>%
  filter(UserType == "CurrentUser") %>%
  group_by(InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalType, InstitutionalCount),
    x = InstitutionalCount,
    fill = InstitutionalType
  )) + geom_bar(stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("") +
  xlab("Count") + 
  #xlab("") +
  ggtitle(bquote(bold("Current Users"))) +
  coord_cartesian(clip = "off") +
  scale_fill_manual(values = c("R1 University" = "#FDB462",
                    "Research Center" = "#FCCDE5",
                    "Medical Center or School" = "#FB8072",
                    "R2 University" = "#B3DE69")) +
  theme(legend.position = "none")

institutionTypeCurrent

#ggsave(here("plots/institutionalType_currentUserResponses.png"), plot = institutionTypeCurrent)
```

#### Just for Potential Users

Here we want to focus on institutions represented by just potential users of AnVIL. 

<details><summary>Description of variable definitions and steps</summary>

We first select rows/responses that are just from potential users. Then we prepare the data and plot following the same scheme as above.

</details>

```{r}
resultsTidy %>%
  filter(UserType == "PotentialUser") %>%
  group_by(InstitutionalAffiliation, InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalAffiliation, InstitutionalCount),
    x = InstitutionalCount,
    fill = InstitutionalType
  )) + geom_bar(stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("Institutional Affiliation") + xlab("Count") +
  ggtitle(bquote('Institutional Affilition for' ~ bold('Potential User') ~ 'Respondents')) +
  annotation_custom(textGrob(paste("There are\n", nrow(unique(resultsTidy[which(resultsTidy$UserType == "PotentialUser"), "InstitutionalAffiliation"]))  ,"\nunique institutions"), gp=gpar(fontsize=8, fontface = "bold")),xmin=6,xmax=6,ymin=1.5,ymax=1.5) +
  coord_cartesian(clip = "off")
  

ggsave(here("plots/institutionalAffilition_potentialUserResponses.png"))
```

Taking a less granular approach, and just looking at institution type rather than names of institutions. 

Wanted to sync the colors between the current and potential institutional types and so used the Set3 palette for scale_fill_brewer as it has 12 colors (and need 9 for current users) and it seemed more accessible than the Paired palette. To see the hex codes that were assigned to the shared institution types in this plot, I used the `scales` library and `brewer_pal(palette = "Set3")(9)`

Turned off the y-axis label, but kept the x-axis label since this will be the bottom plot when combined with the current user version (`institutionTypeCurrent`). Also used `xlim` to sync the x-axis limits between the two. 

Simplified the title to just be Potential Users. Turned off the legend.

```{r}
institutionTypePotential <- resultsTidy %>%
  filter(UserType == "PotentialUser") %>%
  group_by(InstitutionalType) %>% summarize(InstitutionalCount = n()) %>%
  ggplot(aes(
    y = reorder(InstitutionalType, InstitutionalCount),
    x = InstitutionalCount,
    fill = InstitutionalType
  )) + geom_bar(stat = "identity") +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  ylab("") +
  xlab("") +
  #xlab("Count") +
  xlim(0,15) +
  ggtitle(bquote(bold("Potential Users"))) +
  coord_cartesian(clip = "off") +
  scale_fill_brewer(palette = "Set3") +
  theme(legend.position = "none")

institutionTypePotential

#ggsave(here("plots/institutionalType_potentialUserResponses.png"), plot = institutionTypePotential)
```
Combined the two plots for institutional type (`institutionTypeCurrent` and `institutionTypePotential`) using patchwork, stacking them on top of each other (`/`) and using `plot_layout` to set the heights since there are more institution types for Potential users than Current users and therefore want current users to be shorter than default.


```{r}
combined_plot <-  institutionTypePotential / institutionTypeCurrent + plot_layout(heights = unit(c(4, 2),'cm')) + plot_annotation("What institution are you affiliated with?")
  
combined_plot

ggsave(here("plots/institutionalType_facetedUserType.png"), plot = combined_plot)
```

## Highest Degree attained (or in progress)

<details><summary>Description of variable definitions and steps</summary>

First we select the columns of interest from `resultsTidy`: `Degrees` and `UserType`. Then we use `group_by` in conjunction with `summarize( = n())` to add counts for how many of each combo are observed in the data. 

Then we send this data to ggplot and make a bar chart with the x-axis representing the degrees (`reorder`ed by the count number such that higher counts are first (and the sum) because otherwise the 2 MDs are located after the high school and master's in progress bars (1 each)). The y-axis represents the count, and the fill is used to specify user type (current or potential AnVIL users). We use a stacked bar chart and include labels above each bar of the total sum for that degree type.

Used [this Stack Overflow post to label sums above the bars](https://stackoverflow.com/questions/30656846/draw-the-sum-value-above-the-stacked-bar-in-ggplot2)

and used [this Stack Overflow post to remove NA from the legend](https://stackoverflow.com/questions/45493163/ggplot-remove-na-factor-level-in-legend)

The rest of the changes are related to theme and labels and making sure that the numerical bar labels aren't cut off on the top.

</details>

```{r}

resultsTidy %>%
  mutate(UserType = factor(UserType, levels = c("PotentialUser", "CurrentUser"))) %>%
  group_by(Degrees, UserType) %>% 
  summarize(n = n()) %>%
  ggplot(aes(x = reorder(Degrees, -n, sum), 
             y = n, 
             fill = UserType
             )) +
      geom_bar(position = "stack", stat="identity") +
      geom_text(
                  aes(label = after_stat(y), group = Degrees), 
                  stat = 'summary', fun = sum, vjust = -1, size=2
                ) +
      theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust=1)) +
      xlab("Degree") +
      ylab("Count") +
      coord_cartesian(clip = "off") +
      scale_fill_manual(values = c("#E0DD10", "#035C94"), na.translate = F) +
      ggtitle("What is the highest degree you have attained?")

ggsave(here("plots/degree_usertype.png"))
```

## Human Genomic, Non-human Genomic, and Human Clinical Research Experience

<details><summary>Question and possible answers</summary>

>How much experience do you have analyzing the following data categories?

The data categories were

* Human genomic
* Non-human genomic
* Human clinical

and for each category, possible options were

* Not at all experienced
* Slightly experienced
* Somewhat experienced
* Moderately experienced
* Extremely experienced

</details>

### Prepare data

<details><summary>Description of variable definitions and steps</summary>

Here we select the columns containing answers for each data category: `HumanGenomicExperience`, `HumanClinicalExperience`, and `NonHumanGenomicExperience`. We also select `UserType` in case we want to split user type out at all in viewing the data. We use a `pivot_longer` to make a long dataframe that can be grouped and groups counted. The category/column names go to a new column, `researchType` and the values in those columns go to a new column `experienceLevel`. Before we use group by and count, we set the factor level on the new `experienceLevel` column to match the progression from not at all experienced to extremely experienced, and we rename the research categories so that the words have spaces, and we say research instead of experience. Then we use `group_by` and `summarize` to add counts for each combination of research category, experience level, and UserType. These counts are in the new `n` column.

</details>

```{r}
experienceDf <- resultsTidy %>% select(HumanGenomicExperience, HumanClinicalExperience, NonHumanGenomicExperience, UserType) %>%
  pivot_longer(c(HumanGenomicExperience, HumanClinicalExperience, NonHumanGenomicExperience), names_to = "researchType", values_to = "experienceLevel") %>% 
  mutate(experienceLevel = 
                                                                                                                                                          factor(experienceLevel, levels = c("Not at all experienced", "Slightly experienced", "Somewhat experienced", "Moderately experienced", "Extremely experienced")),
         researchType = case_when(researchType == "HumanClinicalExperience" ~ "Human Clinical Research",
                                  researchType == "HumanGenomicExperience" ~ "Human Genomic Research",
                                  researchType == "NonHumanGenomicExperience" ~ "Non-human\nGenomic Research")) %>%
  group_by(researchType, experienceLevel, UserType) %>% summarize(n = n()) 
```

### Plot data

<details><summary>Should we split current users vs potential users?</summary>

Here we use two different plots to show that the distribution of experience level among these three research types is similar when comparing the distribution of current users vs potential users. In this first plot, we have the experience level on the x-axis, the count on the y-axis, and color the bars by research type. We stack the user type responses using `facet_wrap` and `nrow=2` as an argument within that. We use a `position="dodge"` to cluster the similar research type bars next to each other. And we use geom_text to label the bars with the actual count. This requires `group = researchType` within the `geom_text()` `aes()` and `position = position_dodge(width = 0.9)` within the general `geom_text()` function. 

We then also make some theme changes like rotating the x-axis tick labels and changing the y- and x- axis labels and using a minimal theme to turn off borders, and then turning off grids, etc.

```{r}
ggplot(experienceDf, aes(x=experienceLevel,y=n, fill=researchType)) + 
  facet_wrap(~UserType, nrow=2) + 
  geom_bar(stat="identity", position="dodge") + 
  theme_minimal() + 
  theme(panel.background = element_blank(), panel.grid = element_blank()) + 
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  geom_text(
    aes(label = n, group = researchType), 
    size=2, position = position_dodge(width = .9), vjust=-0.5
) + 
  ylab("Count") + xlab ("Reported Experience Level") +
  coord_cartesian(clip = "off")
  

ggsave(here("plots/researchExperienceLevel_colorResearchType.png"))
```

In this second plot, we have the experience level on the x-axis, the count on the y-axis, and color the bars by experience level. We stack the user type responses and separate out the research types into separate facets using `facet_grid`. And we use geom_text to label the bars with the actual count. This uses `group = experienceLevel` within the `geom_text()` `aes()`. 

We then also make some theme changes like rotating the x-axis tick labels and changing the y- and x- axis labels, expanding the left plot margin, and using a minimal theme to turn off borders, and then turning off grids, etc.

```{r}
ggplot(experienceDf, aes(x=experienceLevel,y=n, fill=experienceLevel)) + 
  facet_grid(UserType~researchType) + 
  geom_bar(stat="identity") + 
  theme_classic() + 
  theme(panel.background = element_blank(), panel.grid = element_blank()) + 
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  geom_text(
    aes(label = n, group = experienceLevel), vjust = -1, size=2
) + 
  ylab("Count") + xlab ("Reported Experience Level") +
  coord_cartesian(clip = "off") + 
  theme(plot.margin = margin(1,1,1,1.05, "cm")) +
  theme(legend.position = "none")
  

ggsave(here("plots/researchExperienceLevel_colorExperience.png"))
```

We include both plots in case since we don't know which we like better, but both of these give us confidence that current and potential user counts for reported experience level in these research areas show similar distributions. So we'll go ahead and plot it without splitting out UserType.

</details>

#### Preferred bar plot

<details><summary>Description of variable definitions and steps</summary>

This bar plot has the experience level on the x-axis, the count on the y-axis, and fills the bars according to the experience level (though the fill/color legend is turned off by setting legend.position to none). We facet the research category type and label the bars. We keep a summary stat and sum function and after_stat(y) for the label since the data has splits like UserType that we're not visualizing here. 

We adjust various aspects of the theme like turning off the grid and background and rotating the x-tick labels and changing the x- and y-axis labels. We also slightly widen the left axis so that the tick labels aren't cut off. 

</details>

```{r}
ggplot(experienceDf, aes(x=experienceLevel,y=n, fill=experienceLevel)) + 
  facet_grid(~researchType) + 
  geom_bar(stat="identity") + 
  theme_bw() + 
  theme(panel.background = element_blank(), panel.grid = element_blank()) + 
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  geom_text(
    aes(label = after_stat(y), group = experienceLevel), 
    stat = 'summary', fun = sum, vjust = -0.5, size=2
) + 
  ylab("Count") + xlab ("Reported Experience Level") +
  coord_cartesian(clip = "off") + 
  theme(plot.margin = margin(1,1,1,1.05, "cm")) +
  theme(legend.position = "none") +
  ggtitle("How much experience do you have analyzing the following data categories?")
  

ggsave(here("plots/researchExperienceLevel_colorExperienceLevel_noUserTypeSplit.png"))
```

This is the same plot, but with no color fill on the bars in order to remove redundancy.

```{r}
ggplot(experienceDf, aes(x=experienceLevel,y=n)) + 
  facet_grid(~researchType) + 
  geom_bar(stat="identity") + 
  theme_bw() + 
  theme(panel.background = element_blank(), panel.grid = element_blank()) + 
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  geom_text(
    aes(label = after_stat(y), group = experienceLevel), 
    stat = 'summary', fun = sum, vjust = -0.5, size=2
) + 
  ylab("Count") + xlab ("Reported Experience Level") +
  coord_cartesian(clip = "off") + 
  theme(plot.margin = margin(1,1,1,1.05, "cm")) +
  theme(legend.position = "none")+
  ggtitle("How much experience do you have analyzing the following data categories?")
  

ggsave(here("plots/researchExperienceLevel_noColor_noUserTypeSplit.png"))
```


# Insights

## Comparisons of rank of importance of features/resources between Current Users and Potential Users

>Rank the following features or resources according to their importance for your continued use of the AnVIL

>Rank the following features or resources according to their importance to you as a potential user of the AnVIL?
  
* Easy billing setup
* Flat-rate billing rather than use-based
* Free version with limited compute or storage
* On demand support and documentation
* Specific tools or datasets are available/supported
* Greater adoption of the AnVIL by the scientific community

We're going to look at a comparison of the assigned ranks for these features, comparing between current users and potential users.

### Recode rank values 

<details><summary>Description of variable definitions and steps</summary>

Columns of interest include

* PotentialRankEasyBillingSetup
* PotentialRankFlatRateBilling
* PotentialRankFreeVersion
* PotentialRankSupportDocs
* PotentialRankToolsData
* PotentialRankCommunityAdoption
* CurrentRankEasyBillingSetup
* CurrentRankFlatRateBilling
* CurrentRankFreeVersion
* CurrentRankSupportDocs
* CurrentRankToolsData
* CurrentRankCommunityAdoption

We can use `starts_with` to select these columns, specifically focusing on the starts with "PotentialRank" and "CurrentRank". When we made simplified names for the columns, these are the only twelve that start like that. 

Either the 6 CurrentRank or the 6 PotentialRank were asked to each survey taker which means that we expect NULL values in these columns since not every survey taker will have answered all of these questions.

We want to recode the following values

* Replace 1 (Most important in this list) with 1
* Replace 6 (Least important in this list) with 6

Before we can do that, we first need to change the type of the columns in several ways. We don't want them to be lists. The non-tidyverse way of doing this would be `unlist(as.character(resultsTidy$PotentialRankEasyBillingSetup))`. We can use the `unnest` tidyverse function with a `keep_empty = TRUE` argument so that it preserves the NULL values. Notice in the non-tidyverse way, we had to use `as.character` in order to preserve the null values. In the tidyverse way, we still have to use an as.character type change before the `unnest`, otherwise, we get an error that double and character values can't be combined. 

After the `unnest` we can use the `recode` function to make the replacements specified above. And then we go ahead and change the type from character to integer so that we can compute average rank & plot them more easily. There will be a warning that NAs are introduced by coercion when we change the type to integer. So we add a replacement in the `recode`, changing "NULL" to the `NA_character_`

</details>

```{r}
resultsTidy %<>%
  mutate(across(starts_with(c(
    "PotentialRank", "CurrentRank"
  )), as.character)) %>%
  unnest(starts_with(c("PotentialRank", "CurrentRank")), keep_empty = TRUE) %>%
  mutate(across(
    starts_with(c("PotentialRank", "CurrentRank")),
    ~ recode(
      .x,
      "1 (Most important in this list)" = "1",
      "6 (Least important in this list)" = "6",
      "NULL" = NA_character_
    )
  )) %>%
  mutate(across(starts_with(c(
    "PotentialRank", "CurrentRank"
  )), as.integer))
```

### Numerical response bias

<details><summary>Visualizing the numerical response bias since there were non-unique ranks assigned by some respondents</summary>

```{r}
resultsTidy %>%
  select(starts_with("PotentialRank")) %>%
  rowSums(na.rm = TRUE) %>%
  table() %>% as.data.frame()
```

We would expect a row sum of 21 if a 6, 5, 4, 3, 2, and 1 were selected. We see row sums ranging from  6 (ranking everything 1) to 24. Only 8 out of 28 responses have a row sum of 21 and even that doesn't guarantee that all choices received a unique ranking for those 8 responses (e.g., 3 2's, 1 4, 1 5 and 1 6 sum to 21). So this table is instead showing that 20 responses definitely did not use unique ranks for all 6 questions. Given that most of these observed sums are less than 21, people showed a bias towards ranking things as more important (closer to 1)

```{r}
resultsTidy %>% 
  select(starts_with("CurrentRank")) %>% 
  rowSums(na.rm = TRUE) %>%
  table() %>% as.data.frame()
```

We again would expect a row sum of 21 if a 6, 5, 4, 3, 2, and 1 were selected. We see row sums ranging from  6 (ranking everything 1) to 26. Only 9 out of 22 responses have a row sum of 21 and even that doesn't guarantee that all choices received a unique ranking for those 9 responses (e.g., 3 2's, 1 4, 1 5 and 1 6 sum to 21). So this table is instead showing that 13 responses definitely did not use unique ranks for all 6 questions. Given that most of these observed sums are less than 21, people showed a bias towards ranking things as more important (closer to 1)

We can visualize the numerical response bias where people tended to rate things as more important by creating a density plot of all rankings no matter the feature queried or 

```{r}
resultsTidy %>%
  select(starts_with(c("CurrentRank", "PotentialRank"))) %>%
  pivot_longer(cols = everything()) %>%
  drop_na() %>%
  ggplot(aes(x = value)) +
  geom_density() +
  theme_bw() + theme(panel.background = element_blank()) +
  xlab("Rank") + scale_x_continuous(breaks = 1:6, labels = 1:6)
```

</details>

### Plot dumbbell plot

#### Prepare data

Average rank is total rank (sum of given ranks) divided by number of votes (number of given ranks)

<details><summary>Description of variable definitions and steps</summary>

We make two different dataframes that find the total ranks (column name: `totalRank`) and avg ranks (column name: `avgRank`) for each future and then row bind (`bind_rows`) these two dataframes together to make `totalRanksdf`. The reason that we make two separately are that one is for Potential users (`starts_with("PotentialRank")`) and one is for Current users (`starts_with("CurrentRank")`). They have a different number of votes `nranks` and so it made more sense to work with them separately, following the same steps and then row bind them together.

The individual steps for each of these dataframes is to

* `select` the relevant columns from `resultsTidy`
* perform sums with `colSums`, adding together the ranks in those columns (each column corresponds to a queried feature); We set `na.rm = TRUE` to ignore the NAs (since not every survey respondent was asked each question; e.g., if they were a current user they weren't asked as a potential user)
* send those sums to a data frame such that the selected column names from the first step are now the row names and the total summed rank is the only column with values in each row corresponding to each queried feature
* Use a `mutate` to 
  * add a new column `nranks` that finds the number of responses in the survey are from potential users (e.g., the number that would have assigned ranks to the PotentialRank questions) or the number of responses in the survey that are from current/returning users (e.g., the number that would have assigned ranks to the CurrentRank questions).
  * add a new column `avgRank` that divides the `totalRank` by the `nranks`

After these two dataframes are bound together (`bind_rows`), the rest of the steps are for aesthetics in plotting and making sure ggplot knows the UserType and the feature of interest, etc.

* We move the rownames to their own column `UsertypeFeature` (with the `mutate(UsertypeFeature = rownames(.))`). 
* We separate the values in that column on the word "Rank" to remove the `UsertypeFeature` column we just made but then make two new columns (`Usertype` and `Feature`) where `Usertype is either "Current" or "Potential", and the Features are listed in the code below, because...
* We then use a `case_when` within a `mutate()` to fill out those features so they're more informative and show the choices survey respondents were given. 

</details>

```{r}
totalRanksdf <-
  bind_rows(
    resultsTidy %>% 
      select(starts_with("PotentialRank")) %>% 
      colSums(na.rm = TRUE) %>% 
      as.data.frame() %>% `colnames<-`(c("totalRank")) %>% 
      mutate(nranks = sum(resultsTidy$UserType == "PotentialUser"),
             avgRank = totalRank / nranks),
    resultsTidy %>%
      select(starts_with("CurrentRank")) %>% 
      colSums(na.rm = TRUE) %>% 
      as.data.frame() %>% `colnames<-`(c("totalRank")) %>% 
      mutate(nranks = sum(resultsTidy$UserType == "CurrentUser"),
             avgRank = totalRank /nranks)
  ) %>% 
  mutate(UsertypeFeature = rownames(.)) %>% 
  separate(UsertypeFeature, c("Usertype", "Feature"), sep = "Rank", remove = TRUE) %>%
  mutate(Feature = 
           case_when(Feature == "EasyBillingSetup" ~ "Easy billing setup",
                     Feature == "FlatRateBilling" ~ "Flat-rate billing rather than use-based",
                     Feature == "FreeVersion" ~ "Free version with limited compute or storage",
                     Feature == "SupportDocs" ~ "On demand support and documentation",
                     Feature == "ToolsData" ~ "Specific tools or datasets are available/supported",
                     Feature == "CommunityAdoption" ~ "Greater adoption of the AnVIL by the scientific community"),
         Usertype = factor(case_when(Usertype == "Potential" ~ "Potential Users", 
                                     Usertype == "Current" ~ "Current Users"), levels = c("Potential Users", "Current Users"))
         )
```

#### Dumbbell plot

<details><summary>Description of variable definitions and steps</summary>

We use the `totalRanksdf` we just made. The x-axis is the `avgRank` values, and the y-axis displays the informative `Feature` values, however, we `reorder` the y-axis so that more important (lower number) avgRank features are displayed higher in the plot.

geom_point and geom_line are used in conjunction to produce the dumbbell look of the plot and we set the color of the points to correspond to the `Usertype`

Some theme things are changed, labels and titles added, and then we display and save that plot.

The first version of the plot has trimmed limits, so the second version sets limits on the x-axis of 1 to 6 since those were the options survey respondents were given for ranking. It also adds annotations (using [Grobs, explained in this Stack Overflow post answer](https://stackoverflow.com/a/31081162)) to specify which rank was "Most important" and which was "Least important". 

Then we've also adjusted the left margin so that the annotation isn't cut off.

We then display and save that version as well.

</details>

```{r}
gdumbbell <- ggplot(totalRanksdf, aes(x = avgRank, y = reorder(Feature, -avgRank))) +
  geom_line() +
  geom_point(aes(color = Usertype), size = 3) +
  theme(panel.background = element_blank()) + theme_bw() + theme(legend.position = "bottom") +
  xlab("Average Rank") + 
  ylab("Feature") + 
  ggtitle("Rank the following features according to\ntheir importance to you as a potential user\nor for your continued use of the AnVIL") +
  scale_color_manual(values = c("#E0DD10", "#035C94")) +
  theme(legend.title = element_blank())

gdumbbell

ggsave(here("plots/dumbbellplot_rankfeatures.png"), plot = gdumbbell)

gdumbbell <- gdumbbell + 
  scale_x_continuous(breaks = 1:6, labels = 1:6, limits = c(1,6))+
  annotation_custom(textGrob("Most\nimportant", gp=gpar(fontsize=8, fontface = "bold")),xmin=1,xmax=1,ymin=-0.5,ymax=-0.5) + 
  annotation_custom(textGrob("Least\nimportant", gp=gpar(fontsize=8, fontface= "bold")),xmin=6,xmax=6,ymin=-0.5,ymax=-0.5) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1,1.1, "cm")) +
  scale_color_manual(values = c("#E0DD10", "#035C94"))

gdumbbell

ggsave(here("plots/dumbbellplot_xlim16_rankfeatures.png"), plot = gdumbbell)

gdumbbell <- gdumbbell + 
 scale_x_reverse(limits = c(6,1), breaks = 6:1, labels = 6:1) +
 annotation_custom(textGrob("Most\nimportant", gp=gpar(fontsize=8, fontface = "bold")),xmin=-1,xmax=-1,ymin=-0.5,ymax=-0.5) + 
 annotation_custom(textGrob("Least\nimportant", gp=gpar(fontsize=8, fontface= "bold")),xmin=-6,xmax=-6,ymin=-0.5,ymax=-0.5)

gdumbbell

ggsave(here("plots/dumbbellplot_xlim16_revaxis_rankfeatures.png"), plot = gdumbbell)
  
```

### Plot Density plot

#### Prepare data

<details><summary>Description of variable definitions and steps</summary>

Here, we just want all of the numerical ranks in one column and we can have additional columns that describe if that rank was from a current or potential user and which feature it corresponds to.

So to make a dataframe `densitydf`, we 

* start by selecting the columns of interest from `resultsTidy` using `select(starts_with(c("PotentialRank", "CurrentRank")))
* tell it to take this "wide" dataframe and pivot it to a longer one where the values all go to a `value` column, and the column name associated with the value goes into a `name` column. 
* drop rows that have na with `drop_na()` since as described earlier not every survey respondent was asked each question; e.g., if they were a current user they weren't asked as a potential user.
* Then we `separate` the `name` column on the word "Rank" to remove the `name` column we just made but then make two new columns (`Usertype` and `Feature`) where `Usertype is either "Current" or "Potential", and the Features are listed in the code below, because...
* We then use a `case_when` within a `mutate()` to fill out those features so they're more informative and show the choices survey respondents were given.
* we add another `case_when` within that `mutate` to add the word "Users" to the `Usertypes` column values. 

</details>

```{r}
densitydf <- resultsTidy %>% 
    select(starts_with(c("PotentialRank", "CurrentRank"))) %>% pivot_longer(cols = everything()) %>% drop_na() %>%
  separate(name, c("Usertype", "Feature"), sep = "Rank", remove = TRUE) %>%
    mutate(Feature = 
               case_when(Feature == "EasyBillingSetup" ~ "Easy billing setup",
                         Feature == "FlatRateBilling" ~ "Flat-rate billing rather than use-based",
                         Feature == "FreeVersion" ~ "Free version with limited compute or storage",
                         Feature == "SupportDocs" ~ "On demand support and documentation",
                         Feature == "ToolsData" ~ "Specific tools or datasets are available/supported",
                         Feature == "CommunityAdoption" ~ "Greater adoption of the AnVIL by the scientific community"),
           Usertype =
             case_when(Usertype == "Current" ~ "Current Users",
                       Usertype == "Potential" ~ "Potential Users")
    )
```


#### Density plot

<details><summary>Description of variable definitions and steps</summary>

We use the `densitydf` dataframe we just made and the x-axis is raw rank `value` column values, and the y-axis shows the density. The different density curves are grouped and color filled based off of which feature they represent, and we `facet_wrap` or split the plot facets into two rows so that there's one for each user type. We set the alpha value within `geom_density` since so many of the curves are on top of each other.

Some theme things are changed, labels and titles added, and then we display and save that plot

It also adds annotations (using [Grobs, explained in this Stack Overflow post answer](https://stackoverflow.com/a/31081162)) to specify which rank was "Most important" and which was "Least important". 

And it increases the bottom margin so those grob annotations aren't cutoff

</details>

```{r}
ggplot(densitydf, aes(x=value, group = Feature, fill = Feature)) +
  facet_wrap(~Usertype, nrow = 2) +
  geom_density(alpha=0.3) + 
  theme_bw() + theme(panel.background = element_blank()) +
  xlab("Rank") + scale_x_continuous(breaks = 1:6, labels= 1:6, limits = c(1, 6)) +
  ggtitle("Rank the following features according to\ntheir importance to you as a potential user\nor for your continued use of the AnVIL")+
  annotation_custom(textGrob("Most\nimportant", gp=gpar(fontsize=8, fontface = "bold")),xmin=1,xmax=1,ymin=-0.85,ymax=-0.85) + 
  annotation_custom(textGrob("Least\nimportant", gp=gpar(fontsize=8, fontface= "bold")),xmin=6,xmax=6,ymin=-0.85,ymax=-0.85) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1.25,1, "cm"))
ggsave(here("plots/densityplot_rankfeatures.png"))
```


#### Density plot with facets for feature

<details><summary>Description of variable definitions and steps</summary>

We use the `densitydf` dataframe we just made, but we re-simplify the Features so that they'll fit in the legend. For the plot, the x-axis is raw rank `value` column values, and the y-axis shows the density. The different density curves are grouped and color filled based off of which feature they represent, and we use `facet_grid` to split the plot facets into two rows and 6 columns so that there's one row for each user type and one column per feature. We switch the row/y-axis labels over to the left (using `switch = "y"`) and remove the column/x-axis labels (using `theme(strip.background.x = element_blank(), strip.text.x = element_blank())`)

We use the `unit()` function to create some margins, and then set the plot margins and legend position within another `theme()`. I used [this Stack Overflow post to find this method.](https://stackoverflow.com/questions/29808620/ggplot2-move-legend-to-corner-but-keep-it-in-margin) 

Some theme things are changed, labels and titles added, and then we display and save that plot

</details>

```{r}
margins = unit(c(1, 10, 1, 1), 'lines')

densitydf %>% 
  mutate(Feature = 
           case_when(Feature == "Easy billing setup" ~ "Easy billing setup",
                     Feature == "Flat-rate billing rather than use-based" ~ "Flat-rate billing",
                     Feature == "Free version with limited compute or storage" ~ "Free version",
                     Feature == "On demand support and documentation" ~ "Support & documentation",
                     Feature == "Specific tools or datasets are available/supported" ~ "Specific tools or datasets",
                     Feature == "Greater adoption of the AnVIL by the scientific community" ~ "More community adoption")
        ) %>% 
  ggplot(aes(x=value, group = Feature, fill = Feature)) +
  facet_grid(Usertype~Feature, switch = "y") +
  geom_density() + 
  theme_bw() + theme(panel.background = element_blank()) + #theme(legend.position = "bottom") +
  theme(strip.background.x = element_blank(), strip.text.x = element_blank()) +
  theme(plot.margin=margins, legend.position=c(1.25, 0.5)) +
  xlab("Rank") + scale_x_continuous(breaks = 1:6, labels= 1:6, limits = c(1, 6)) +
  ggtitle("Rank the following features according to their importance to you as a\npotential user or for your continued use of the AnVIL")+
  coord_cartesian(clip = "off")
  
ggsave(here("plots/densityplot_rankfeatures_faceted.png"))
```

### Plot Stacked Bar Chart showing number of times for each rank rather than average

#### Prepare data (count)

<details><summary>Description of variable definitions and steps</summary>

For this, we want a data frame that gives counts for all of the ranks given to each feature by each UserType.

To do this we 

  * Select the relevant columns from `resultsTidy`, specifically using  `select(starts_with(c("PotentialRank", "CurrentRank")))`
  * tell it to take this "wide" dataframe and pivot it to a longer one (`pivot_longer`) where the values all go to a `value` column, and the column name associated with the value goes into a `name` column.
  * drop rows that have na with `drop_na()` since as described earlier not every survey respondent was asked each question; e.g., if they were a current user they weren't asked as a potential user.
  * group by the name (feature and UserType combined) and value (the rank) and have it count the number of that specific rank for each feature/UserType combo
  * rename the columns because it's getting confusing. name stays name, value changes to rank, and n is used for the count.
  * Then we `separate` the `name` column on the word "Rank" to remove the `name` column but then make two new columns (`Usertype` and `Feature`) where `Usertype is either "Current" or "Potential", and the Features are listed in the code below, because...
  * We then use a `case_when` within a `mutate()` to fill out those features so they're more informative and show the choices survey respondents were given.
  * we add another `case_when` within that `mutate` to add the word "Users" to the `Usertypes` column values.
  * set the ranks to be a factor (treated like a categorical variable with a better color scheme instead of a continuous one if we didn't do this) with a specified level so that the most important rank is the first bar on the left when we plot.

</details>

```{r}
countdf <- resultsTidy %>% 
    select(starts_with(c("PotentialRank", "CurrentRank"))) %>% 
  pivot_longer(cols = everything()) %>% 
  drop_na() %>% 
  group_by(name, value) %>% count() %>% 
  `colnames<-`(c("name", "rank", "n")) %>%
  separate(name, c("Usertype", "Feature"), sep = "Rank", remove = TRUE) %>%
  mutate(Feature = 
           case_when(Feature == "EasyBillingSetup" ~ "Easy billing setup",
                     Feature == "FlatRateBilling" ~ "Flat-rate billing rather than use-based",
                     Feature == "FreeVersion" ~ "Free version with limited compute or storage",
                     Feature == "SupportDocs" ~ "On demand support and documentation",
                     Feature == "ToolsData" ~ "Specific tools or datasets are available/supported",
                     Feature == "CommunityAdoption" ~ "Greater adoption of the AnVIL by the scientific community"),
        Usertype =
            case_when(Usertype == "Current" ~ "Current Users",
                      Usertype == "Potential" ~ "Potential Users"),
        rank = factor(rank, levels = c(6:1))
    )
```

#### Stacked bar chart

<details><summary>Description of variable definitions and steps</summary>

Using the `countdf` dataframe that we just made, we have the count or `n` column on the x-axis, the `Feature` on the y-axis, and the fill of the bars to be the `rank` (categorical 1, 2, 3, 4, 5, 6). We facet wrap on UserType with two rows so that each facet represents a different UserType. 

We use the `position = "fill"` argument in `geom_bar()` so that it's a percent stacked bar instead of raw counts (since current and potential users had a different number of respondents)

We set the labels for the legend so that it specifies which rank is Least important and which is most important, and we reverse the order in the legend so 1 is on top on the legend. 

Finally we set labels and titles and change the theme a bit

</details>

```{r}
ggplot(countdf, aes(fill=rank, y=Feature, x=n)) +
  facet_wrap(~Usertype, nrow=2) +
    geom_bar(position="fill", stat="identity") +
  scale_fill_discrete(labels=c('6 (Least\n    Important)', '5', '4', '3', '2', '1 (Most\n    Important)')) +
  guides(fill = guide_legend(reverse = TRUE)) +
  xlab("Percent Responses") +
  ggtitle("Rank the following features according to\ntheir importance to you as a potential user\nor for your continued use of the AnVIL") +
  theme_bw() + theme(panel.background = element_blank(), panel.grid = element_blank())

ggsave(here("plots/stackedbarplot_rankfeatures.png"))
```

## Tool Knowledge and Comfort Separate from the AnVIL and on the AnVIL

>How would you rate your knowledge of or comfort with these technologies (separate from the AnVIL)?

>How would you rate your knowledge of or comfort with these technologies (on the AnVIL)?

>How would you rate your knowledge of or comfort with these AnVIL data features?

Shared technologies between these two questions include

* Jupyter Notebooks: `CurrentAnVILTechJupyterNotebooks` & `AllTechJupyterNotebooks`
* Bioconductor & RStudio: `CurrentAnVILTechRStudio` & `AllTechRStudio` + `AllTechBioconductor`
* Galaxy: `CurrentAnVILTechGalaxy` & `AllTechGalaxy`
* WDL Workflows / Workflows (e.g., WDL): `CurrentAnVILTechWDL` & `AllTechWorkflows`
* Containers: `CurrentAnVILTechContainers` & `AllTechContainers`
* Unix / Command Line: `CurrentAnVILTechCommandLine` & `AllTechCommandLine`

Technologies only asked separate from the AnVIL

* Python: `AllTechPython`
* R: `AllTechR`

Technologies/data features only asked with regards to the AnVIL

* Accessing controlled access datasets: `CurrentAnVILTechAccessData`
* DUOS (Data Use Oversight System): `CurrentAnVILTechDUOS`
* Terra on AnVIL (Workspaces): `CurrentAnVILTechTerra`
* TDR (Terra Data Repository): `CurrentAnVILTechTDR`

Possible answers for each of these questions include

* Don't know it (0)
* Not at all comfortable (1)
* Slightly comfortable (2)
* Somewhat comfortable (3)
* Moderately comfortable (4)
* Extremely comfortable (5)

Notated possible "comfort scores" in parentheses next to each possible answer. We'll add these as additional columns that now start with the word "Score_" but otherwise retain the column name, in case it's helpful to still have the words (whose factor level we'll set to reflect the progression of knowledge/comfort).

Responses are NA if the question wasn't asked to the survey taker (e.g., they were a potential user and weren't asked about technologies with regards to the AnVIL)

It's likely that someone who's a program administrator will select don't know for these.... should we remove them and see how average scores change?

```{r}
resultsTidy %<>%
  mutate(across(starts_with(c(
    "CurrentAnVILTech", "AllTech"
  )), as.character)) %>%
  unnest(starts_with(c("CurrentAnVILTech", "AllTech")), keep_empty = TRUE) %>%
  mutate(across(starts_with(c(
    "CurrentAnVILTech", "AllTech"
  )), ~ parse_factor(
    .,
    levels = c(
      "Don't know it",
      "Not at all comfortable",
      "Slightly comfortable",
      "Somewhat comfortable",
      "Moderately comfortable",
      "Extremely comfortable"
    )
  ))) %>%
  mutate(across(
    starts_with(c("CurrentAnVILTech", "ALLTech")),
    ~ case_when(
      . == "Don't know it" ~ 0,
      . == "Not at all comfortable" ~ 1,
      . == "Slightly comfortable" ~ 2,
      . == "Somewhat comfortable" ~ 3,
      . == "Moderately comfortable" ~ 4,
      . == "Extremely comfortable" ~ 5
    )
    ,
    .names = "Score_{.col}"
  ))
```

### Dumbbell like plot

#### Prepare the data

```{r}
toPlot <- bind_rows(
  resultsTidy %>%
    filter(UserType == "CurrentUser") %>%
    select(starts_with("Score_")) %>%
    colSums(na.rm = TRUE) %>%
    as.data.frame() %>% `colnames<-`(c("totalScore")) %>%
    mutate(nscores = sum(resultsTidy$UserType == "CurrentUser"),
          avgScore = totalScore / nscores,
          UserType = "Current Users") %>%
  mutate(WhereTool = rownames(.)) %>%
  separate(WhereTool, c("AnVILorNo", "Tool"), sep = "Tech", remove = TRUE) %>%
  mutate(AnVILorNo = 
           case_when(AnVILorNo == "Score_CurrentAnVIL" ~ "On the AnVIL",
                     AnVILorNo == "Score_All" ~ "Separate from the AnVIL"
                     ),
         Tool = 
           recode(Tool, "JupyterNotebooks" = "Jupyter Notebooks",
                  "WDL" = "Workflows",
                  "CommandLine" = "Unix / Command Line",
                  "AccessData" = "Access controlled access data",
                  "Terra" = "Terra Workspaces",
                  "BioconductorRStudio" = "Bioconductor & RStudio"
                  )
         ),

  resultsTidy %>%
    filter(UserType == "PotentialUser") %>%
    select(starts_with("Score_AllTech")) %>%
    colSums() %>%
    as.data.frame() %>% `colnames<-`(c("totalScore")) %>%
    mutate(nscores = sum(resultsTidy$UserType == "PotentialUser"),
           avgScore = totalScore / nscores,
           UserType = "Potential Users") %>%
    mutate(WhereTool = rownames(.)) %>%
    separate(WhereTool, c("AnVILorNo", "Tool"), sep = "Tech", remove = TRUE) %>%
    mutate(AnVILorNo = 
           case_when(AnVILorNo == "Score_CurrentAnVIL" ~ "On the AnVIL",
                     AnVILorNo == "Score_All" ~ "Separate from the AnVIL"
                     ),
           Tool = 
           recode(Tool, "JupyterNotebooks" = "Jupyter Notebooks",
                  "WDL" = "Workflows",
                  "CommandLine" = "Unix / Command Line",
                  "AccessData" = "Access controlled access data",
                  "Terra" = "Terra Workspaces",
                  "BioconductorRStudio" = "Bioconductor & RStudio"
                  )
          )
) %>%
  mutate(UserType = factor(UserType, levels = c("Potential Users", "Current Users")))
```

```{r}
toPlot_simplified <- toPlot %>%
  filter(AnVILorNo == "Separate from the AnVIL") %>%
  filter(UserType != "Both Types of Users")
```

```{r}
onAnVIL <- toPlot %>%
  filter(AnVILorNo == "On the AnVIL") %>%
  right_join(., toPlot_simplified,by = "Tool") %>%
  bind_rows(., 
            data.frame(Tool = "RStudio", 
                       avgScore.x = toPlot[which(toPlot$Tool == "Bioconductor & RStudio"),"avgScore"],
                       UserType.x = "Current Users",
                       AnVILorNo.x = "On the AnVIL"),
            data.frame(Tool = "Bioconductor", 
                       avgScore.x = toPlot[which(toPlot$Tool == "Bioconductor & RStudio"),"avgScore"],
                       UserType.x = "Current Users",
                       AnVILorNo.x = "On the AnVIL")
            ) %>% drop_na(avgScore.x)
```


```{r}
roi <- toPlot[which(toPlot$Tool == "Bioconductor & RStudio"),]
toPlot <- rows_append(toPlot, data.frame(
          UserType = rep(roi$UserType,2),
          avgScore = rep(roi$avgScore,2),
          AnVILorNo = rep(roi$AnVILorNo,2),
          Tool = c("Bioconductor", "RStudio")
  )) %>%
  rows_delete(., data.frame(roi))
```


#### Plot the dumbbell like plot

Used [this Stack Overflow response](https://stackoverflow.com/a/72309061) to get the values for the `scale_shape_manual()`

```{r}
ggplot(toPlot, aes(y = reorder(Tool, avgScore), x = avgScore)) + geom_point(aes(color = UserType, shape = AnVILorNo)) + scale_x_continuous(breaks = 0:5, labels = 0:5, limits = c(0,5)) + ylab("Tool or Data Resource") + xlab("Average Knowledge or Comfort Score") + theme_bw() + theme(panel.background = element_blank(), panel.grid.minor.x = element_blank()) + #facet_wrap(~UserType, nrow=3) +
annotation_custom(textGrob("Don't know\nat all", gp=gpar(fontsize=8, fontface = "bold")),xmin=0,xmax=0,ymin=-2,ymax=-2) + 
  annotation_custom(textGrob("Extremely\ncomfortable", gp=gpar(fontsize=8, fontface= "bold")),xmin=5,xmax=5,ymin=-2,ymax=-2) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1,1.1, "cm")) +
  ggtitle("How would you rate your knowledge of or\ncomfort with these technologies or data features?") +
  scale_color_manual(values = c("#E0DD10", "#035C94")) +
  scale_shape_manual(values = c(4, 16))
  

ggsave(here("plots/tooldataresourcecomfortscore_singlepanel.png"))

simplerPlot <- ggplot(toPlot_simplified, aes(y = reorder(Tool, avgScore), x=avgScore)) + geom_point(aes(color = UserType)) + 
  geom_line() + 
  scale_x_continuous(breaks = 0:5, labels = 0:5, limits = c(0,5)) + ylab("Tool or Resource") + xlab("Average Knowledge or Comfort Score") + theme_bw() + theme(panel.background = element_blank(), panel.grid.minor.x = element_blank()) + 
  annotation_custom(textGrob("Don't know\nat all", gp=gpar(fontsize=8, fontface = "bold")),xmin=0,xmax=0,ymin=-1.5,ymax=-1.5) + 
  annotation_custom(textGrob("Extremely\ncomfortable", gp=gpar(fontsize=8, fontface= "bold")),xmin=5,xmax=5,ymin=-1.5,ymax=-1.5) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1,1.1, "cm"))+
  ggtitle("How would you rate your knowledge of or\ncomfort with these technologies\n(separate from the AnVIL)?")

simplerPlot

ggsave(here("plots/toolsSeparateFromAnVIL_comfortscore.png"), plot = simplerPlot)
```




```{r}
simplerPlot + geom_point(data = onAnVIL, aes(x=avgScore.x,y=Tool),colour="#C77CFF")
#how to add label for what purple point is?

ggsave(here("plots/tools_comfortscore.png"))
```

```{r}
toPlot %>%
  filter(Tool == "DUOS" | Tool == "Access controlled access data" | Tool == "TDR" | Tool == "Terra Workspaces") %>%
  ggplot(aes(y = reorder(Tool, avgScore), x=avgScore)) + geom_point(colour = "#F8766D") + 
  scale_x_continuous(breaks = 0:5, labels = 0:5, limits = c(0,5)) + ylab("Data Resource") + xlab("Average Knowledge or Comfort Score") + theme_bw() + theme(panel.background = element_blank(), panel.grid.minor.x = element_blank()) + 
  annotation_custom(textGrob("Don't know\nat all", gp=gpar(fontsize=8, fontface = "bold")),xmin=0,xmax=0,ymin=-0.35,ymax=-0.35) + 
  annotation_custom(textGrob("Extremely\ncomfortable", gp=gpar(fontsize=8, fontface= "bold")),xmin=5,xmax=5,ymin=-0.35,ymax=-0.35) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1,1.1, "cm"))+
  ggtitle("How would you rate your knowledge of or\ncomfort with these AnVIL data features?")

ggsave(here("plots/dataresources_comfortscore.png"))
```

## What datasets would respondents like to access? Which ones are most popular?

>What large, controlled access datasets do you access or would you be interested in accessing using the AnVIL?
  
* All of Us*
* Centers for Common Disease Genomics (CCDG)
* The Centers for Mendelian Genomics (CMG)
* Clinical Sequencing Evidence-Generating Research (CSER)
* Electronic Medical Records and Genomics (eMERGE)
* Gabriella Miller Kids First (GMKF)
* Genomics Research to Elucidate the Genetics of Rare Diseases (GREGoR)
* The Genotype-Tissue Expression Project (GTEx)
* The Human Pangenome Reference Consortium (HPRC)
* Population Architecture Using Genomics and Epidemiology (PAGE)
* Undiagnosed Disease Network (UDN)
* UK Biobank*
* None
* Other (Free Text Response)

Since this is a select all that apply question, we expect that there will be multiple responses that are comma separated. The free text responses will likely need recoded as well. The responses are in the `AccessWhichControlledData` column.

### Prepare the data

<details><summary>Description of variable definitions and steps</summary>

Making a function `prep_df_whichData()` since we'll be using this workflow a few times for different subsets of the data, because we want to be able to differentially display the data based on the experience status (experienced with clinical research, human genomics research, etc.) of the person saying they'd like access to the data.

We want to color the bars based on whether or not the controlled access dataset is available on the AnVIL currently. We create a dataframe `onAnVILDF` to report this. Used the [AnVIL dataset catalog/browser](https://explore.anvilproject.org/datasets) to find out this information. However, HPRC and  GREGoR don't show up in that resource, but are both available per these sources: [Announcement for HPRC](https://anvilproject.org/news/2021/03/11/hprc-on-anvil), [Access for HPRC](https://anvilproject.org/data/consortia/HPRC), [Access for GREGoR](https://anvilproject.org/data/consortia/GREGoR). Both GMKF and TCGA are data hosted on other NCPI platforms that are accessible via AnVIL because of interoperability. (See: https://www.ncpi-acc.org/ and https://ncpi-data.org/platforms). We list these as non-AnVIL hosted since while accessible, they are not AnVIL hosted and inaccessible without NCPI. Finally, UDN is described as non-AnVIL hosted as it is in the Data submission pipeline and not yet available. 

We'll join this anvil-hosted or not data with the actual data at the end.

Given the input `subset_df`, we expect several answer to be comma separated. Since there are 12 set possible responses (not including "None") and one possible free response answer, we separate the `AccessWhichControlledData` column into 13 columns ("WhichA" through "WhichN"), separating on a comma (specifically a ", " a comma followed by a space, otherwise there were duplicates where the difference was a leading space). Alternative approaches should [consider using `str_trim`](https://stringr.tidyverse.org/reference/str_trim.html). We set fill to "right" but this shouldn't really matter. It's just to suppress the unnecessary warning that they're adding NA's when there aren't 13 responses. If there's only one response, it'll put that response in `WhichA` and fill the rest of them with `NA`. If there's two responses, it'll put those two responses in `WhichA` and `WhichB` and fill the rest of them with `NA`... etc,

We then use `pivot_longer` to grab these columns we just made and put the column names in a new column `WhichChoice` and the values in the each column to a new column `whichControlledAccess`. We drop all the NAs in this new `whichControlledAccess` column (and there's a lot of them there)...

Then we group by the new `whichControlledAccess` column and summarize a count for how many there are for each response.

Then we pass this to a mutate and recode function to simplify the fixed responses to be just their acronyms, to remove asterisks (that let the survey respondent know that that dataset wasn't available because of policy restrictions), and to recode the free text responses (details below in "Notes on free text response recoding").

We use a `left_join()` to join the cleaned data with a dataframe that specifies whether that dataset is currently available on the AnVIL or not. It's a left join rather than a full join so it's only adding the annotation for datasets that are available in the results.

Finally, we return this subset and cleaned dataframe so that it can be plotted.

</details>

<details><summary>Notes on free text response recoding</summary>

There were 4 "Other" free response responses

* "Being able to pull other dbGap data as needed." 
  --> We recoded this to be an "Other"
* "GnomAD and ClinVar" 
  --> GnomAD and ClinVar are not controlled access datasets so we recoded that response to be "None"
* "Cancer omics datasets" 
  --> We recoded this to be an "Other"
* "TCGA"
  --> This response was left as is since there is a controlled access tier.

</details>

```{r}
prep_df_whichData <- function(subset_df){
  
  onAnVILDF <- data.frame(whichControlledAccess = c( #checking on this
  "All of Us",
  "UK Biobank",
  "CCDG",
  "CMG",
  "CSER",
  "eMERGE",
  "GMKF",
  "GREGoR",
  "GTEx",
  "HPRC",
  "PAGE",
  "UDN",
  "Other",
  "None",
  "TCGA"
  ),
onAnVIL= c(
  "non-AnVIL hosted",
  "non-AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "non-AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "AnVIL hosted",
  "non-AnVIL hosted",
  NA,
  NA,
  "non-AnVIL hosted"
  )
)
  
  subset_df %<>% separate(AccessWhichControlledData, c("WhichA", "WhichB", "WhichC", "WhichD", "WhichE", "WhichF", "WhichG", "WhichH", "WhichI", "WhichJ", "WhichK", "WhichM", "WhichN"), sep = ", ", fill="right") %>%
  pivot_longer(starts_with("Which"), names_to = "WhichChoice", values_to = "whichControlledAccess") %>%
  drop_na(whichControlledAccess) %>%
  group_by(whichControlledAccess) %>% summarize(count = n()) %>%
  mutate(whichControlledAccess =
           recode(whichControlledAccess,
             "All of Us*" = "All of Us",
             "UK Biobank*" = "UK Biobank",
             "Centers for Common Disease Genomics (CCDG)" = "CCDG",
             "The Centers for Mendelian Genomics (CMG)" = "CMG",
             "Clinical Sequencing Evidence-Generating Research (CSER)" = "CSER",
             "Electronic Medical Records and Genomics (eMERGE)" = "eMERGE",
             "Gabriella Miller Kids First (GMKF)" = "GMKF",
             "Genomics Research to Elucidate the Genetics of Rare Diseases (GREGoR)" = "GREGoR",
             "The Genotype-Tissue Expression Project (GTEx)" = "GTEx",
             "The Human Pangenome Reference Consortium (HPRC)" = "HPRC",
             "Population Architecture Using Genomics and Epidemiology (PAGE)" = "PAGE",
             "Undiagnosed Disease Network (UDN)" = "UDN",
             "Being able to pull other dbGap data as needed." = "Other",
             "Cancer omics datasets" = "Other",
             "GnomAD and ClinVar" = "None", #not controlled access
                  )
  ) %>% left_join(onAnVILDF, by="whichControlledAccess")
    
  return(subset_df)
}
```

<details><summary>Description of variable definitions and steps</summary>

Here we set up 4 data frames for plotting

* The first uses all of the responses and sends them through the `prep_df_whichData()` function to clean the data for plotting to see which controlled access datasets are the most popular.
* The second filters to grab just the responses from those experienced in clinical research using the `clinicalFlag` column (described earlier in the Clean Data -> Simplified experience status for various research categories (clinical, human genomics, non-human genomics) subsection)
* The third filters to grab just the responses from those experienced in human genomic research using the `humanGenomicFlag` column (described earlier in the Clean Data -> Simplified experience status for various research categories (clinical, human genomics, non-human genomics) subsection)
* The fourth filters to grab just the responses from those experienced in non-human genomic research using the `nonHumanGenomicFlag` column (described earlier in the Clean Data -> Simplified experience status for various research categories (clinical, human genomics, non-human genomics) subsection)

</details>

```{r}
whichDataDf <- resultsTidy %>% prep_df_whichData()

whichDataClinicalSubset <- resultsTidy %>%
  filter(clinicalFlag == TRUE) %>%
  prep_df_whichData()

whichDataHumanGenomicSubset <- resultsTidy %>%
  filter(humanGenomicFlag == TRUE) %>%
  prep_df_whichData()

whichDataNonHumanGenomicSubset <- resultsTidy %>%
  filter(nonHumanGenomicFlag == TRUE) %>%
  prep_df_whichData()

```

### Plot the data

<details><summary>Description of variable definitions and steps</summary>

Also have a function here because it's the same plotting steps for each just changing the subtitle and which dataframe is used as input.

This takes the input dataframe and plots a bar plot with the x-axis having the controlled access datasets listed (reordering the listing based off of the count so most popular is on the left), the count number/popularity of requested is on the y-axis, and the fill is based on whether the dataset is available on AnVIL or not. 

We change the theme elements like removing panel borders, panel background, and panel grid, and rotate the x-axis tick labels. We add an x- and y- axis label and add a title (and subtitle if specified - which it will be when we're looking at just a subset like those who are experienced with clinical data)

We also add text labels above the bars to say how many times each dataset was marked/requested. Note that we have to use the after_stat, summary, and sum way of doing it again because we use recoding and if we want the labels to be accurate, it has to capture every time we've recoded things to be the same after we used group_by and summarize to count before we recoded. It uses `coord_cartesian(clip = "off")` so these bar text labels aren't cut off and finally returns the plot.

We call this function 4 times

* once for all the data (and don't use a subtitle)
* next for just those experienced with clinical data (using a subtitle to specify this)
* next for just those experienced with human genomic data (using a subtitle to specify this)
* and finally for just those experienced with non-human genomic data (using a subtitle to specify this)

</details>

```{r}

plot_which_data <- function(inputToPlotDF, subtitle = NULL){

  toreturnplot <- ggplot(inputToPlotDF, aes(x = reorder(whichControlledAccess, -count), y = count, fill = onAnVIL)) +
    geom_bar(stat="identity") + 
    theme_classic() + theme(panel.background = element_blank(), panel.grid = element_blank()) +
    theme(axis.text.x = element_text(angle=45, hjust=1)) +
    xlab("Controlled access datasets") + ylab("Count") + 
    ggtitle("What large, controlled access datasets do you access\nor would you be interested in accessing using the AnVIL?", subtitle = subtitle) + 
    geom_text(aes(label = after_stat(y), group = whichControlledAccess),
                  stat = 'summary', fun = sum, vjust = -1, size=2) +
  coord_cartesian(clip = "off") + 
  scale_fill_manual(values = c("#25445A", "#7EBAC0", "grey"))

return(toreturnplot)

}

```

```{r}
everyoneDataPlot <- plot_which_data(whichDataDf)

everyoneDataPlot

ggsave(here("plots/whichcontrolleddata.png"), plot = everyoneDataPlot)
```

```{r}
clinicalDataPlot <- plot_which_data(whichDataClinicalSubset, subtitle = "Respondents moderately or extremely experienced with clinical data")

clinicalDataPlot

ggsave(here("plots/whichcontrolleddata_clinical.png"), plot = clinicalDataPlot)
```

```{r}
humanGenomicDataPlot <- plot_which_data(whichDataHumanGenomicSubset, subtitle = "Respondents moderately or extremely experienced with human genomic data")

humanGenomicDataPlot

ggsave(here("plots/whichcontrolleddata_humangenomic.png"), plot = humanGenomicDataPlot)
```

```{r}
nonHumanGenomicDataPlot <- plot_which_data(whichDataNonHumanGenomicSubset, subtitle = "Respondents moderately or extremely experienced with non-human genomic data")

nonHumanGenomicDataPlot

ggsave(here("plots/whichcontrolleddata_nonhumangenomic.png"), plot = nonHumanGenomicDataPlot)
```

## Types of Data respondents would want to analyze on the AnVIL

<details><summary>Question and possible answers</summary>

>What types of data do you or would you analyze using the AnVIL?

Possible answers include

* Genomes/exomes
* Transcriptomes
* Metagenomes
* Proteomes
* Metabolomes
* Epigenomes
* Structural
* Single Cell
* Imaging
* Phenotypic
* Electronic Health Record
* Metadata
* Survey
* Other (with free text response)

</details>

<details><summary>Description of variable definitions and steps</summary>

Because the responses for this data are going to look very similar to the controlled access dataset question (above), we'll follow similar reasoning here in how we prepare and plot the data.

</details>

### Prepare the data

```{r}
prep_df_typeData <- function(subset_df){
  subset_df %<>% separate(TypesOfData, c("WhichA", "WhichB", "WhichC", "WhichD", "WhichE", "WhichF", "WhichG", "WhichH", "WhichI", "WhichJ", "WhichK", "WhichM", "WhichN", "WhichO"), sep = ", ", fill="right") %>%
  pivot_longer(starts_with("Which"), names_to = "WhichChoice", values_to = "whichTypeData") %>%
  drop_na(whichTypeData) %>%
  group_by(whichTypeData) %>% summarize(count = n()) %>%
  mutate(whichTypeData =
           recode(whichTypeData,
                  "I don't analyze data on AnVIL" = NA_character_,
                  "I store data in AnVIL. I don’t analyze it." = NA_character_,
                  "Used in training for analysis of genomes (variant calling)" = "Variant Calling"
                  )
         ) %>%
  drop_na(whichTypeData)
  return(subset_df)
}
```

```{r}
typeOfDataDf <- resultsTidy %>% prep_df_typeData()

typeDataClinicalSubset <- resultsTidy %>%
  filter(clinicalFlag == TRUE) %>%
  prep_df_typeData()

typeDataHumanGenomicSubset <- resultsTidy %>%
  filter(humanGenomicFlag == TRUE) %>%
  prep_df_typeData()
```

### Plot the data

```{r}

plot_type_data <- function(inputToPlotDF, subtitle = NULL){
  toreturnplot <- ggplot(inputToPlotDF, aes(x = reorder(whichTypeData, -count), y = count)) +
    geom_bar(stat="identity") + 
    theme_classic() + theme(panel.background = element_blank(), panel.grid = element_blank()) +
    theme(axis.text.x = element_text(angle=45, hjust=1)) +
    xlab("Types of data") + ylab("Count") + 
    ggtitle("What types of data do you or would you analyze using the AnVIL?", subtitle = subtitle) +
    geom_text(aes(label = after_stat(y), group = whichTypeData), 
                  stat = 'summary', fun = sum, vjust = -1, size=2) +
    coord_cartesian(clip = "off")
  return(toreturnplot)
}
```

```{r}
everyone_type_data <- plot_type_data(typeOfDataDf)

everyone_type_data

ggsave(here("plots/typesOfData.png"), plot=everyone_type_data)
```

```{r}
clinical_type_data <- plot_type_data(typeDataClinicalSubset, subtitle = "Respondents moderately or extremely experienced with clinical data")

clinical_type_data

ggsave(here("plots/typesOfData_clinical.png"), plot=clinical_type_data)
```

```{r}
humangenomic_type_data <- plot_type_data(typeDataHumanGenomicSubset, subtitle = "Respondents moderately or extremely experienced with human genomic data")

humangenomic_type_data

ggsave(here("plots/typesOfData_humangenomic.png"), plot=humangenomic_type_data)
```

## Source of funds for cloud computing

> What source(s) of funds do you use to pay for cloud computing?

Possible answers include 

* NHGRI
* Other NIH
* Foundation Grant
* Institutional funds
* Don't know
* Only use free options
* Other (with free text entry if Other is selected)

The only Other response in this set of responses is NSF. 

Answers are stored in the `FundingSources` column. This question was a select all that apply, so answers will be comma separated, and this question was asked to all survey takers.

### Prepare the data

<details><summary>Description of variable definitions and steps</summary>

</details>

```{r}
toPlotFundingSource <- resultsTidy %>% separate(FundingSources, c("WhichA", "WhichB", "WhichC", "WhichD", "WhichE", "WhichF", "WhichG"), sep = ", ", fill="right") %>%
  pivot_longer(starts_with("Which"), names_to = "WhichChoice", values_to = "whichFundingSource") %>%
  drop_na(whichFundingSource) %>%
  group_by(whichFundingSource, UserType) %>% summarize(count = n())
```

### Plot the data

<details><summary>Description of variable definitions and steps</summary>

</details>

```{r}

toPlotFundingSource %>% ggplot(aes(y = reorder(whichFundingSource,count), x = count, fill = UserType)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = c("#E0DD10", "#035C94")) +
  theme_bw() +
  ggtitle("What source(s) of funds do you use to pay for cloud computing?") +
  xlab("Count") +
  ylab("Funding Source") +
  theme(panel.background = element_blank(),
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank())

ggsave(here("plots/fundingsources.png"))
```

```{r}
toPlotFundingSource %>% 
  mutate(UserType = case_when(
    UserType == "CurrentUser" ~ "Current",
    UserType == "PotentialUser" ~ "Potential"
         ),
   whichFundingSource = factor(whichFundingSource, levels = rev(c("NHGRI", "Other NIH", "Institutional funds", "Foundation Grant", "NSF", "Only use free options", "Don't know")))
  ) %>%
  ggplot(aes(y = UserType, x = count, fill = whichFundingSource)) +
  geom_bar(position = "fill", stat = "identity") +
  scale_fill_manual(values = rev(c("#035C94", "#012840", "#F2F2F2", "#E0DD10", "#AEEBF2", "#7EBAC0", "#333333"))) +
  theme_bw() +
  ggtitle("What source(s) of funds do you use to pay for cloud computing?") +
  xlab("Fraction of responses") +
  ylab("User Type") +
  theme(panel.background = element_blank(),
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank()) +
  labs(fill="Funding Source")
  

ggsave(here("plots/fundingsources_colorSource.png"))
```

## Preference for training modality

>Please rank how/where you would prefer to attend AnVIL training workshops.

Possible answers include 

* On-site at my institution: `AnVILTrainingWorkshopsOnSite`
* Virtual: `AnVILTrainingWorkshopsVirtual`
* Conference (e.g., CSHL, AMIA): `AnVILTrainingWorkshopsConference`
* AnVIL-specific event: `AnVILTrainingWorkshopsSpecEvent`
* Other: `AnVILTrainingWorkshopsOther`

The responses are stored in the starts with `AnVILTrainingWorkshops` columns


### Prepare the data

```{r}

resultsTidy %<>%
  mutate(across(starts_with(
    "AnVILTrainingWorkshops"), as.character)) %>%
  unnest(starts_with("AnVILTrainingWorkshops"), keep_empty = TRUE) %>%
  mutate(across(
    starts_with("AnVILTrainingWorkshops"),
    ~ recode(
      .x,
      "1 (Most preferred in this list)" = "1",
      "5 (Least preferred in this list)" = "5",
      "NULL" = NA_character_
    )
  )) %>%
  mutate(across(starts_with("AnVILTrainingWorkshop"), as.integer))

```

```{r}
toPlotTrainingRanks <- bind_rows(
  resultsTidy %>%
    filter(UserType == "CurrentUser") %>%
    select(starts_with("AnVILTrainingWorkshops")) %>%
    colSums(na.rm = TRUE) %>%
    as.data.frame() %>% `colnames<-`(c("totalRank")) %>%
    mutate(nranks = sum(resultsTidy$UserType == "CurrentUser"),
          avgRank = totalRank / nranks,
          UserType = "Current Users") %>%
  mutate(TrainingType = rownames(.)) %>%
  mutate(TrainingType = str_replace(TrainingType, "AnVILTrainingWorkshops", "")),
  resultsTidy %>%
    filter(UserType == "PotentialUser") %>%
    select(starts_with("AnVILTrainingWorkshops")) %>%
    colSums() %>%
    as.data.frame() %>% `colnames<-`(c("totalRank")) %>%
    mutate(nranks = sum(resultsTidy$UserType == "PotentialUser"),
           avgRank = totalRank / nranks,
           UserType = "Potential Users") %>%
    mutate(TrainingType = rownames(.)) %>%
    mutate(TrainingType = str_replace(TrainingType, "AnVILTrainingWorkshops", ""))
  ) %>% mutate(TrainingType = recode(TrainingType, "SpecEvent" = "AnVIL-specific event", "OnSite" = "On-site at my institution", "Conference" = "Conference (e.g., CSHL, AMIA)")) %>%
  mutate(UserType = factor(UserType, levels = c("Potential Users", "Current Users")))

```

### Plot the data

```{r}
tdumbbell <- ggplot(toPlotTrainingRanks, aes(x = avgRank, y = reorder(TrainingType, -avgRank))) +
  geom_line() +
  geom_point(aes(color = UserType), size = 3) +
  theme(panel.background = element_blank()) + theme_bw() + theme(legend.position = "bottom") +
  xlab("Average Rank") + 
  ylab("Training Workshop Modality") + 
  ggtitle("Please rank how/where you would prefer to attend\nAnVIL training workshops.") +
  scale_color_manual(values = c("#E0DD10", "#035C94")) +
  theme(legend.title=element_blank())

tdumbbell

ggsave(here("plots/dumbbellplot_trainingmodalitypref.png"), plot = tdumbbell)

tdumbbell <- tdumbbell + 
  scale_x_continuous(breaks = 5:1, labels = 5:1, limits = c(1,5))+
  annotation_custom(textGrob("Most\npreferred", gp=gpar(fontsize=8, fontface = "bold")),xmin=1,xmax=1,ymin=-0.5,ymax=-0.5) + 
  annotation_custom(textGrob("Least\npreferred", gp=gpar(fontsize=8, fontface= "bold")),xmin=5,xmax=5,ymin=-0.5,ymax=-0.5) +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1,1,1,1.1, "cm"))
  

tdumbbell

ggsave(here("plots/dumbbellplot_xlim15_trainingmodalitypref.png"), plot = tdumbbell)

tdumbbell <- tdumbbell +
  scale_x_reverse(limits = c(5,1)) +
  annotation_custom(textGrob("Most\npreferred", gp=gpar(fontsize=8, fontface = "bold")),xmin=-1,xmax=-1,ymin=-0.5,ymax=-0.5) + 
  annotation_custom(textGrob("Least\npreferred", gp=gpar(fontsize=8, fontface= "bold")),xmin=-5,xmax=-5,ymin=-0.5,ymax=-0.5)
  
tdumbbell

ggsave(here("plots/dumbbellplot_xlim15_revaxis_trainingmodalitypref.png"), plot = tdumbbell)

```

## Session Info

```{r}
sessionInfo()
```

